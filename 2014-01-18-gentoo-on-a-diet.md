---
layout: post
title: "Gentoo on a diet"
description: ""
category: 
tags: []
---
{% include JB/setup %}

Данный текст является ответом на [статью](http://zaufi.github.io/gentoo/2013/08/02/portage-diet/), где описана настройка пакетного менеджера paludis (и его фронтенда cave) в связке с rsync для исключения части портеджа из процесса синхронизации. Однако все описанное, по большей части, относится к настройкам программы rsync и может быть легко использовано в стандартной утилите emerge.



<h1>Мотивация</h1>
Вкратце, автор предлагает написание фильтров для rsync в виде скелетон-файла. В дальнейшем, этот файл обрабатывается специальным скриптом для экстраполяции данных правил на директорию `metadata/md5-cache`. После чего в настройках пакетного менеджера прописывается использование полученного фала с окончательными фильтрами.

Дерево портеджей устроено следующим образом:

    . корень (/usr/portage, как правило)
    |
    |--каталоги, отражающие список категорий пакетов (как правило, состоят из двух слов,
    |  разделенных знаком `-` — `app-editors`, например)
    |  |
    |  |--каталоги, отражающие список пакетов, принадлежащих данной категории
    |     |--непосредственно файлы e-билдов, манифесты, каталоги с патчами и т.д.
    |
    |--интересующий нас каталог `metadata/md5-cache`
    |  |-- каталоги, отражающие список категорий пакетов (повторяет те же имена, что и в корне)
    |      |--файлы md5-сумм для всех e-билдов из дерева. Что важно, именуются они
    |         по схеме `ИМЯ_ПАКЕТА-ВЕРСИЯ`, где имя пакета дублирует название
    |         e-bild-файла из основного дерева
    |
    |--прочие каталоги: e-классы, профили, лицензии, скрипты и т.д.

Именно тем, что категории и пакеты фигурируют тут в двух ипостасях — в дереве e-билдов и в дереве md5-кэша, вызвана раздражающая необходимость запускать скрипт, генерирующий дополнительные фильтры.

Почистить разрастающееся дерево портеджа от ненужных пакетов — это отличная идея, и я ухватился за возможность воспользоваться приведенным в вышеозначенной статье рецептом. Однако, при попытке наивно продублировать этот же подход для чуть более сложных фильтров, были выявлены некоторые проблемы. Чем и спешу поделиться.

<b>Пробема 1:</b>
Автор использует следующее правило для исключения пакета (или пакетов) из дерева `- app-editors/vim*/***`. На основе этого правила, банальной подстановкой, будет сгенерировано дополнительно правило для файлов md5-кеша: `- metadata/md5-cache/app-editors/gvim*/***`. Это сработало бы для удаления категории, которая представляет собой каталог. Но это не работает для пакетов, которые, как сказано выше, представляют собой каталог в дереве портеджа, но при этом фигурируют как обычные файлы в md5-cache директории. Посему, с прискорбием вынужден констатировать, что свежесгенерированный фильтр ничего не фильтрует.

<b>Проблема 2:</b>
Первая проблема всего-лишь досадна. Серьезнее все это становится в другом случае. В частности, я столкнулся с ситуацией, когда было необходимо удалить целую категорию, за исключением одного-двух явно указанных пакетов. Что и было реализовано связкой включающих фильтров (+) для пакетов и исключающего фильтра (-) для содержащей их категории. Вот тут сгенерированные фильтры показали свое коварство. Поскольку не было найдено соответствия с правилами включения, то исключающее правило удалило всю директорию с md5-кешем для данной категории, несмотря на то, что несколько пакетов в дереве осталось. Печально.



<h1>Решение</h1>
Вероятно, все это лишь следствие недосмотра. Скорее всего, предполагалось, что выражения в фильтрах матчатся с началом имени синхронизируемого объекта. Но маны rsync-а говорят нам:

>If the pattern starts with a `/` then it is anchored to a particular spot in the hierarchy of files, otherwise it is matched against the end of the pathname. This is similar to a leading `^` in regular expressions. Thus `"/foo"` would match a name of `"foo"` at either the "root of the transfer" (for a global rule) or in the merge-file’s directory (for a per-directory rule). An unqualified `"foo"` would match a name of `"foo"` anywhere in the tree because the algorithm is applied recursively from the top down; it behaves as if each path component gets a turn at being the end of the filename. Even the  unanchored `"sub/foo"` would match at any point in the hierarchy where a `"foo"` was found within a directory named `"sub"`.

Т.е., если в правиле не указан лидирующий слэш, то будет искаться соответствие выражения с концом строки. А поскольку это так, то мы можем обойтись небольшим изменением исходных правил без всякой дополнительной генерации. Одним и тем же правилом мы исключим и сам пакет и файлы его md5-кеша, если заменим в правиле финальный слэш (указывающий на то, что это всегда директория) на две звездочки (говорящие, что это может быть как файл, так и директория с произвольным количеством вложенных объектов)



<h1>Типы фильтров для корректного использования</h1>
Удаление категории со всеми пакетами

    - app-emacs/***

Удаление отдельного пакета

    - app-editors/emacs**

Удаление всех пакетов из категории, кроме нескльких явно указанных

    + app-accessibility/at-spi2-atk**
    + app-accessibility/at-spi2-core**
    - app-accessibility/**

Правила для удаления прочего ненужного (но не имеющего зависимых файлов в md5-cache) имеет смысл начинать со слэша, чтобы указать rsync-у, искать совпадения, основываясь на позиции

    - /profiles/arch/alpha/***
    - /eclass/tests/***

Использованием таких правил мы решаем сразу обе проблемы. Скрипт, генерирующий дополнительные фильтры, становится просто не нужен. И не остается никаких хвостов от удаленных из дерева пакетов.
